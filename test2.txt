package com.enstage.test.rest.dw;


import ch.qos.logback.classic.AsyncAppender;
import com.codahale.metrics.health.HealthCheck;
import com.enstage.hsm.HSMInterface;
import com.enstage.messagingqueue.MessagingQueue;
import com.enstage.pc.common.Cache;
import com.enstage.pc.common.CoreConfig;
import com.enstage.pc.common.CoreConfig.CachesConfig;
import com.enstage.pc.common.CoreSettings;
import com.enstage.pc.common.couchbase.CouchbaseInstaller;
import com.enstage.test.core.CoreAPIUtil;
import com.enstage.test.core.quartz.config.Job;
import com.enstage.test.core.quartz.config.JobsBundle;
import com.enstage.test.core.quartz.job.*;
import com.enstage.test.core.util.CrossDomainFilter;
import com.enstage.test.health.*;
import com.enstage.test.rest.dw.cfg.TestRestApiCfg;
import com.enstage.test.rest.resources.ShortURLCreateResource;
import com.enstage.test.rest.resources.ShortURLResource;
import com.enstage.test.rest.resources.am.TestCardResource;
import com.enstage.test.rest.resources.caller.CallerAuthResource;
import com.enstage.test.rest.resources.external.ExternalMerchantResource;
import com.enstage.test.rest.resources.funds.DestinationOfFunds;
import com.enstage.test.rest.resources.funds.SourceOfFunds;
import com.enstage.test.rest.resources.instaCashback.ServiceDeliveryResource;
import com.enstage.test.rest.resources.internal.*;
import com.enstage.test.rest.resources.logView.LogView;
import com.enstage.test.rest.resources.plcc.PLCC_AuthCallBack_Resource;
import com.enstage.test.rest.resources.plcc.PLCC_Resource;
import com.enstage.test.rest.resources.program.MultiProgram;
import com.enstage.test.rest.resources.program.ProgramResource;
import com.enstage.test.rest.resources.promo.PromoCodeResource;
import com.enstage.test.rest.resources.ruleEngine.MasterRuleResource;
import com.enstage.test.rest.resources.system.BBPSComplaintResource;
import com.enstage.test.rest.resources.system.UPIDataResource;
import com.enstage.test.rest.resources.transaction.*;
import com.enstage.test.rest.resources.transaction.iap.*;
import com.enstage.test.rest.resources.user.*;
import com.enstage.test.rest.resources.user.messages.UserMessageResource;
import com.enstage.test.rest.resources.util.*;
import com.enstage.test.service.impl.RegisterDeviceImpl;
import com.fasterxml.jackson.module.kotlin.KotlinModule;
import com.test.wallet.common.couchbase.CouchBaseRes;
import com.test.wallet.common.db.ExternalRes;
import com.test.wallet.common.db.PostgressRes;
import com.test.wallet.common.exception.CryptoException;
import com.test.wallet.common.parameters.PCInstances;
import io.dropwizard.Application;
import io.dropwizard.setup.Bootstrap;
import io.dropwizard.setup.Environment;
import org.apache.log4j.BasicConfigurator;
import org.glassfish.jersey.filter.LoggingFilter;
import org.slf4j.LoggerFactory;

import javax.servlet.DispatcherType;
import java.lang.management.ManagementFactory;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

//import com.enstage.test.rest.resources.kotlin.CalculatorResource;			- Uncomment for Kotlin Use
//import com.enstage.test.rest.resources.kotlin.KotlinHealthCheckResource; 	- Uncomment for Kotlin Use
//import com.enstage.test.rest.resources.kotlin.TestUserResource;			- Uncomment for Kotlin Use

/**
 *
 * @author ashetty, @date 27/1/16 7:10 PM
 */
public class TestRestApi extends Application<TestRestApiCfg> {
    private static final Logger logger =  Logger.getLogger(TestRestApi.class.getName());

    public static final String APP_ID = "wallet";
    public static final String APP_VERSION = "0";
    public static final String REST_API_VERSION = System.getProperty("REST_API_VERSION");
    public static final String REST_API_BUILD_DATE = System.getProperty("REST_API_BUILD_DATE");

    public static final String DEFAULT_NODE_ID = "apD1";
    public static final String DEFAULT_NODE_URL = "https://api.test.com";

    public static void main(String[] args) throws Exception {
        new TestRestApi().run(new String[]{"server", System.getProperty("test.config")});

        /**
         *  @author madhavan
         *  Uncomment below for taking the Kotlin route in configuring and application
         *  If uncommented make sure you use Kotlin Configuration and Application Classes
         *  Refer CalculatorConfig.kt and CalculatorApp.kt
         *  Also the resource should not be registered in run() method of this class
         *  In Kotlin the below is invoked like this-
         *  fun main(args: Array<String>) {CalculatorApp().run(*args)}
         *  NOTE: To use this route, you also need to create a yml file named kotlinTest.yml
         *  Place it in your cfg folder and have an entry like - name: Kotlin Calculator
         */
        //new CalculatorTestApp().run(new String[]{"server", "cfg/kotlinTest.yml"});
    }

    @Override
    public void initialize(Bootstrap<TestRestApiCfg> bootstrap) {
    		// Initialize quartz jobs only for the MAIN CLUSTER
    		logger.info("batch jobs started....................");
    		String mainCluster = System.getProperty("MAIN_CLUSTER");
    		if (mainCluster != null && mainCluster.equals("TRUE")) {
    			Job markForGeneratingXelerateFileQuartzJob = new MarkForGeneratingXelerateFileQuartzJob();
        		Job generateBankXelerateFileQuartzJob = new GenerateBankXelerateFileQuartzJob();
        		Job updateWalletCreationDateQuartzJob = new UpdateWalletCreationDateQuartzJob();
                        Job generateUserKYCDetailsQuartzJob = new GenerateUserKYCDetailsQuartzJob();
                        Job genericETLQuartzJob = new GenericETLQuartzJob();
                        Job blockWalletQuartzJob = new BlockWalletQuartzJob();
                        Job offerBannerQuartzJob =  new OfferBannerQuartzJob();
                        Job bulkTestP2MerchantCaptureFundQuartzJob= new BulkTestP2MerchantCaptureFundQuartzJob();
                        Job triggerEmailVerificationJob = new TriggerEmailVerificationJob();
                        Job updateKYCOnPANValidationJob = new UpdateKYCOnPANValidationJob();
                        Job blockWalletForNonBiometricKYCJob = new BlockWalletForNonBiometricKYCJob();
                        Job amcUserDetailsCaptureJob = new AMCUserDetailsCaptureJob();
                        Job amcBillingDetailsCaptureJob = new AMCBillingDetailsCaptureJob();
                        Job blockWalletForNonKycUsers = new BlockWalletForNonKYCUsersJob();
                        Job testP2MerchantFundCaptureQuartzJob = new TestP2MerchantFundCaptureQuartzJob();
                        Job newUserKYCLevelUpgradeQuartzJob = new NewUserKYCLevelUpgradeQuartzJob();
                        Job kycLevelUpgradeQuartzJob = new KYCLevelUpgradeQuartzJob();
                        Job kycAutoUpgradeQuartzJob = new KYCAutoUpgradeQuartzJob();
                        Job ekycLevelUpgradeQuartzJob = new EKYCLevelUpgradeQuartzJob();
                        Job bulkFundLoadQuartzJob = new BulkFundLoadQuartzJob();
                        Job bharathQRInstantCashBackQuartzJob = new BharathQRInstantCashBackQuartzJob();
                        Job bankURLKYCQuartzJob = new BankURLKYCQuartzJob();
                        Job bankAccountReconQuartzJob = new BankAccountReconQuartzJob();
                        Job monthlyTableQuartzJob = new MonthlyTableQuartzJob();
                        Job walletCloseBalanceJob = new WalletCloseBalanceJob();
                        Job updateOnlineKYCJob= new UpdateOnlineKYCJob();
                        Job kycRemainderJob = new KYCRemainderJob();
                        Job instantCashBackQuartzJob = new InstantCashBackQuartzJob();
                        Job updateCloseWalletJob = new UpdateCloseWalletJob();
                        Job netBankingReconQuartzJob = new NetBankingReconQuartzJob();
                Job upiReconQuartzJob = new UPIReconQuartzJob();
                Job upiPgAPIRetryFailureQuartzJob = new UPIPgAPIRetryFailureQuartzJob();
                Job updateQRPushExpiryJob = new UpdateQRPushExpiryJob();
//                        Job merchantIAPMasterUpdateQuartzJob = new MerchantIAPMasterUpdateQuartzJob();
                Job refreshAccessTokenJob = new RefreshAccessTokenJob();
                //Job refreshUserAccessTokenJob = new RefreshUserAccessTokenJob();
                Job instantCashBackUpdateQuartzJob = new InstantCashBackUpdateQuartzJob();
                Job promoConfirmQuartzJob = new PromoConfirmQuartzJob();
                Job pcIapOctStatusUpdateQuartzJob = new PCIapOctStatusUpdateQuartzJob();
                Job upiRefundTxnStatusUpdateQuartzJob = new UPIRefundEnqStatusUpdateQuartzJob();
                Job pgFileUpload = new PGFileUploadQuartzJob();
                Job cbFileUpload = new CashBackFileUploadQuartzJob();
                Job kycUpgradeRemainderJob = new KYCUpgradeReminderQuartzJob();
                Job releasePromoCodeJob = new ReleasePromoCodeJob();
                Job walletExpiry30DRemainderJob = new WalletCardExpiryReminderQuartzJob();
                Job walletExpiry45DRemainderJob = new WalletCardExpiry45DReminderQuartzJob();
                Job walletExpiryExtensionJob = new WalletCardExpiryExtensionQuartzJob();
                Job pgEnquiryQuartzJob = new PGEnquiryQuartzJob();
                Job upiTxnEnquiryQuartzJob = new UPITxnEnquiryQuartzJob();
               // Job updateVelocityPostTxnFailureJob = new UpdateVelocityForPendingTxnQuartzJob();
                Job dataSyncWithPrepaidJob = new DataSyncWithPrepaidJob(); //Wallet status syncing job
                Job pendingCMSUpdateJob = new PendingCMSUpdateQuartzJob();
                Job pendingKycEnquiryJob = new PendingKycEnquiryQuartzJob();
                Job getRetailDisputeListJob = new GetRetailDisputeListJob();
                Job kycDowngradeJob = new KycDowngradeQuartzJob();
				//Below Jobs Codes are added, but right now not in use.
				//Job tridentP2PJob = new TridentP2PJob();
                //Job tridentW2AJob = new TridentW2AJob();
                //Job tridentLoginJob = new TridentLoginJob();
                //Job tridentRegistrationJob = new TridentRegistrationJob();
                Job pGMerchantOnboardingAPIRetryFailureQuartzJob = new PGMerchantOnboardingAPIRetryFailureQuartzJob();
                Job toknizationQuartzJob = new TokenizationQuartzJob();
                Job deleteTokenizationQuartzJob = new DeleteTokenizationQuartzJob();

                Job[] jobs = new Job[]{
                        markForGeneratingXelerateFileQuartzJob,
                        generateBankXelerateFileQuartzJob,
                        updateWalletCreationDateQuartzJob,
                        generateUserKYCDetailsQuartzJob,
                        genericETLQuartzJob,
                        blockWalletQuartzJob,
                        offerBannerQuartzJob,
                        bulkTestP2MerchantCaptureFundQuartzJob,
                        triggerEmailVerificationJob,
                        updateKYCOnPANValidationJob,
                        blockWalletForNonBiometricKYCJob,
                        amcUserDetailsCaptureJob,
                        amcBillingDetailsCaptureJob,
                        blockWalletForNonKycUsers,
                        testP2MerchantFundCaptureQuartzJob,
                        newUserKYCLevelUpgradeQuartzJob,
                        kycLevelUpgradeQuartzJob,
                        kycAutoUpgradeQuartzJob,
                        ekycLevelUpgradeQuartzJob,
                        bulkFundLoadQuartzJob,
                        bharathQRInstantCashBackQuartzJob,
                        bankURLKYCQuartzJob,
                        bankAccountReconQuartzJob,
                        monthlyTableQuartzJob,
                        updateOnlineKYCJob,
                        kycRemainderJob,
                        instantCashBackQuartzJob,
                        walletCloseBalanceJob,
                        updateCloseWalletJob,
                        refreshAccessTokenJob,
                        instantCashBackUpdateQuartzJob,
                        netBankingReconQuartzJob,
                        upiReconQuartzJob,
                        upiPgAPIRetryFailureQuartzJob,
                        instantCashBackUpdateQuartzJob,
                        pgFileUpload,
                        pcIapOctStatusUpdateQuartzJob,
                        upiRefundTxnStatusUpdateQuartzJob,
                        promoConfirmQuartzJob,
                        cbFileUpload,
                        kycUpgradeRemainderJob,
                        updateQRPushExpiryJob,
//                       //refreshUserAccessTokenJob,
//                        merchantIAPMasterUpdateQuartzJob
                        releasePromoCodeJob,
                        walletExpiry30DRemainderJob,
                        walletExpiry45DRemainderJob,
                        walletExpiryExtensionJob,
                      //  updateVelocityPostTxnFailureJob,
                        pgEnquiryQuartzJob,
                        upiTxnEnquiryQuartzJob,
                        pGMerchantOnboardingAPIRetryFailureQuartzJob,
                        dataSyncWithPrepaidJob,
                        pendingCMSUpdateJob,
                        pendingKycEnquiryJob,
                        getRetailDisputeListJob,
                        kycDowngradeJob,
                        //tridentP2PJob,
                        //tridentW2AJob,
                        //tridentLoginJob,
                        //tridentRegistrationJob
                        toknizationQuartzJob,
                        deleteTokenizationQuartzJob

            };
            bootstrap.addBundle(new JobsBundle(jobs));
        }
        /**
         *  In order to deserialize Kotlin data classes we have to register Jacksonâ€™s
         *  Kotlin Module and Object Mapper
         *  Uncomment for Kotlin use
         */
        bootstrap.getObjectMapper().registerModule(new KotlinModule());
    }

    @Override
    public void run(TestRestApiCfg cfg, Environment env) throws CryptoException {
        TestRestApiCfg.setInstance(cfg);
        String nameOfRunningVM = ManagementFactory.getRuntimeMXBean().getName();
        int pi = nameOfRunningVM.indexOf('@');
        String pid = nameOfRunningVM.substring(0, pi);
        String nodeId = cfg.getNodeId();
        if(nodeId == null || nodeId.length() == 0){
            nodeId = DEFAULT_NODE_ID;
            cfg.setNodeId(nodeId);
        }
        logger.log(Level.INFO, "App id :{0}", nodeId);
        Map<String, Object>urls = cfg.getUrls();
        if(urls == null || urls.isEmpty()){
            logger.warning("No urls set");
            urls = new HashMap<>();
            urls.put("api", DEFAULT_NODE_URL);
            cfg.setUrls(urls);
        }
        CoreSettings.setDbSchemaNames(cfg.getDbSchemaNames());
        logger.log(Level.INFO ,"Schema names  :{0} test :{1}", new Object[]{ CoreSettings.getDbSchemaNames(), CoreSettings.getDbSchemaName("in", "6019", CoreSettings.DB_TXN)});
        Set<String> keys = urls.keySet();
        Iterator<String> keysI = keys.iterator();
        while(keysI.hasNext()){
            final String key = keysI.next();
            logger.log(Level.INFO, "Url {0} :{1}", new Object[]{key, urls.get(key)});
        }
        CoreSettings.setNodeId(nodeId);
        CoreSettings.setUrls(urls);
        CoreSettings.setVersion(TestRestApi.REST_API_VERSION);
        CoreSettings.putASetting(CoreSettings.CSR_TOKEN_VALI_SECONDS, cfg.getCsrTokensValiditySeconds());
        CoreConfig.setMe(cfg.getCoreConfig());
        CoreConfig cc = CoreConfig.getMe();
        logger.log(Level.INFO, "CoreConfig {0}", cc);
        CachesConfig cf = cc.getCachesConfig();
        logger.log(Level.INFO, "Core cong cache impl {0}\n {1}.", new Object[]{cf.getImpl(), cf.getCaches().get(Cache.GENERAL_CACHE)});
        boolean enableLogback = true;

        if(enableLogback) {
            ch.qos.logback.classic.Logger root = (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(ch.qos.logback.classic.Logger.ROOT_LOGGER_NAME);
            AsyncAppender appender = (AsyncAppender) root.getAppender("async-console-appender");
            if(appender!=null) {
                appender.setIncludeCallerData(true);
            }

            AsyncAppender fileAppender = (AsyncAppender) root.getAppender("async-file-appender");
            fileAppender.setIncludeCallerData(true);
        }

        BasicConfigurator.configure();//log4j
        logger.fine("Server Version: "+TestRestApi.REST_API_VERSION);
        logger.log(Level.FINE, "Server PID: {0}", new Object[]{pid});

        /*
        Map<String, Object> properties = new HashMap<>();
        properties.put(ServerProperties.WADL_FEATURE_DISABLE, false);
        env.jersey().getResourceConfig().addProperties(properties);
        */

//        JmxReporter.forRegistry(env.metrics()).build().start(); // Manually add JMX reporting (Dropwizard regression)

        ExternalRes externalRes = ExternalRes.getInstance();
        boolean isExternal = cfg.isExternal();
        boolean logRequestAndResponse = cfg.isLogRequestAndResponse();
        PostgressRes postgressRes = PostgressRes.getInstance();
        postgressRes.setProgramConnectionMapper(cfg.getPostgressPools());
        postgressRes.setInstace(postgressRes);

        System.out.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        System.out.println("Server Version\t: "+TestRestApi.REST_API_VERSION);
        System.out.println("Build Date\t: "+TestRestApi.REST_API_BUILD_DATE);
        System.out.println("Server PID\t: "+pid);
        System.out.println("isExternal\t: "+isExternal);
        System.out.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

        //-- HSM
        HSMInterface hsmInterface = cfg.getHsmFactory().build(env);
        externalRes.setHsmInterface(hsmInterface);
        externalRes.setParamKetAlias(cfg.getHsmFactory().getParamKey());

        CrossDomainFilter.setAlllowdDomains(cfg.getAllowedDomains());

        HSMHealthCheck hsmHealthCheck = new HSMHealthCheck(hsmInterface);
        HealthCheck.Result result = hsmHealthCheck.execute();
        //old method to compare (result!=HealthCheck.Result.healthy()) wont work as ever call to healthy returns a new object now with different time stamp
        if(result.isHealthy() == false) {
            System.err.println("\nIs hsm up? JVM will exit. Health Check Result: "+result.toString());
            System.exit(-1);
            return;
        }
        env.healthChecks().register("hsm", hsmHealthCheck);
        //-- HSM

        //-- DB MYSQL
        try {
            externalRes.initDB(cfg.isEnableConnectionPoolLeakCheck(),cfg.getDatabaseSet(),cfg.getMetricsFactory(), env);
            DBHealthCheck dbHealthCheck = new DBHealthCheck();
            result = dbHealthCheck.execute();
            if(result.isHealthy() == false) {
                System.err.println("\nIs DB up? JVM will exit. Health Check Result: "+result.toString());
                System.exit(-1);
                return;
            }
            env.healthChecks().register("db", dbHealthCheck);
        } catch(Exception e) {
            logger.log(Level.WARNING, "Error: "+e, e);
            System.err.println("\nIs DB up? JVM will exit.");
            System.exit(-1);
        }
        //-- DB

        //-- DB Postgress
        if(cfg.isPostgresEnabled()){
            try {
                externalRes.initPostGressSQLDB(cfg.isEnableConnectionPoolLeakCheck(), cfg.getPostgressDBList(), cfg.getMetricsFactory(), env);
                DBHealthCheck dbHealthCheck = new DBHealthCheck();
                result = dbHealthCheck.execute();
                if(result.isHealthy() == false) {
                    System.err.println("\nIs postgress Db up? JVM will exit. Health Check Result: "+result.toString());
                    System.exit(-1);
                    return;
                }
                externalRes.setPostgresEnabled(true);
                env.healthChecks().register("postgressDb", dbHealthCheck);
            } catch(Exception e) {
                logger.log(Level.WARNING, "Error: "+e, e);
                System.err.println("\nIs DB up? JVM will exit.");
                System.exit(-1);
            }
        }

        //-- DB

        if(cfg.isHealthCheckEnabled()){
            logger.log(Level.INFO, "Health is enable for the CMS , MPI  and OTP");

            //-- CMS
            CMSHealthCheck cmsHealthCheck = new CMSHealthCheck();
            result = cmsHealthCheck.execute();
            if(result.isHealthy() == false) {
                System.err.println("\nIs CMS up? JVM will exit. Health Check Result: "+result.toString());
                System.exit(-1);
                return;
            }
            env.healthChecks().register("cms", cmsHealthCheck);
            //-- CMS

            //--OTP
            OTPHealthCheck otpHealthCheck = new OTPHealthCheck();
            result = otpHealthCheck.execute();
            if(result.isHealthy() == false) {
                System.err.println("\nIs OTP up? JVM will exit. Health Check Result: "+result.toString());
                System.exit(-1);
                return;
            }
            env.healthChecks().register("otp", otpHealthCheck);
            //--OTP

            //--MPI
            MPIHealthCheck mpiHealthCheck = new MPIHealthCheck();
            result = mpiHealthCheck.execute();
            if(result.isHealthy() == false) {
                System.err.println("\nIs MPI up? JVM will exit. Health Check Result: "+result.toString());
                System.exit(-1);
                return;
            }
            env.healthChecks().register("mpi", mpiHealthCheck);
            //--MPI
        /*
        --AsyncDB
        AsyncDBHealthCheck asyncDBHealthCheck = new AsyncDBHealthCheck();
        result = asyncDBHealthCheck.execute();
        env.healthChecks().register("asyncDB", asyncDBHealthCheck);
        --AsyncDB
        */
        }else{
            logger.log(Level.INFO, "Health is not enable for the CMS , MPI  and OTP");
        }

        //--CB
        try {
            logger.info("Started Couchbase Initialization....");
            CouchBaseRes.getInstance().setupCouchbaseCluster(cfg.getCouchDbList(),cfg.getCacheBuckets(), env);

            logger.info("Couchbase Initialization completed. Disable above line during Dev testing.");
        } catch (Exception e) {
            logger.log(Level.WARNING, "Error: " + e, e);
            System.err.println("\nIs CB up? JVM will exit.");
            System.exit(-1);
        }
        //--CB


        if(logRequestAndResponse){
            System.out.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
            System.out.println("Logging request/response is enabled.");
            System.out.println("Please make sure, it is disabled in production");
            System.out.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
            env.jersey().register(new LoggingFilter(Logger.getLogger("InboundRequestResponse"), true));
        }
        //exposed in both internal and external.
        
        env.servlets().addFilter("csrTokenValidateFilter", com.enstage.test.core.util.CsrTokenValidateFilter.class).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), true, "/csrReports/*");
        logger.log(Level.INFO, "ad filters-1 {0}", env.servlets().toString());
        if (cfg.getMessagingQueue() != null) {
            MessagingQueue.setRmq(cfg.getMessagingQueue());
            MessageQueueHelper messageQueueHelper = new MessageQueueHelper();
            env.lifecycle().manage(messageQueueHelper);
        }



        if(isExternal) {
            //--- external services only ---           
           
            env.jersey().register(new CryptoResource());
           
            //--- external services only ---

        } else {
            //internal services only ---
           
            //env.jersey().register(new TestTestResource()); // resource for encryption and decrption
            
        }
        env.jersey().register(new TestServicesResource());
        /* commented its not required
        FilterRegistration.Dynamic filter = env.servlets().addFilter("CORSFilter", CrossOriginFilter.class);
        final String allowed =  cfg.getAllowedDomains();
        logger.log(Level.INFO, "Cors allowed :{0}]", allowed);
        if("-all-".equals(allowed)){
        	cfg.setAllowedDomains("*");
        }
        filter.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), false, env.getApplicationContext().getContextPath() + "*");
        filter.setInitParameter(ALLOWED_ORIGINS_PARAM, cfg.getAllowedDomains());
        filter.setInitParameter(ALLOWED_HEADERS_PARAM, "X-Requested-With,Content-Type,Accept,Origin");
        filter.setInitParameter(ALLOWED_METHODS_PARAM, "GET,PUT,POST,OPTIONS");
        filter.setInitParameter(ACCESS_CONTROL_ALLOW_ORIGIN_HEADER, "true");//origin, content-type, accept, authorization

        filter.setInitParameter(ALLOW_CREDENTIALS_PARAM, "true");
        */
        // added filter for all /pub/* request validation
        env.servlets().addFilter("publicRequestValidationFilter", com.enstage.test.core.util.PublicRequestValidationFilter.class)
                .addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), true, "/pub/*");



        // added filter for all /usr/* request validation
        env.servlets().addFilter("userRequestValidationFilter", com.enstage.test.core.util.UserRequestValidationFilter.class)
                .addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), true, "/usr/*");

        CoreAPIUtil.getGlobalInstance();
        CouchbaseInstaller.init();

        ClearCardObjectThread cardObjectThread=new ClearCardObjectThread();
        cardObjectThread.start();

        // this enables the CORS for the web application
        env.servlets().addFilter("crossDomainFilter", CrossDomainFilter.class).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), true, "/*");

        //Test Service InterIP Range filter
        Set<String> instanceIDList = PCInstances.getGeoInstanceIDList();
        Set<String> urlsMapping = new HashSet<>();
        for(String instance : instanceIDList) {
            urlsMapping.add("/testServices/"+instance.toLowerCase()+"/internal/*");
            urlsMapping.add("/testServices/"+instance.toUpperCase()+"/internal/*");
        }
        env.servlets().addFilter("testServicesInternalFilter", com.enstage.test.core.util.TestServicesInternalFilter.class)
                .addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), true, urlsMapping.toArray(new String[urlsMapping.size()]));

    }

}

****************************************
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.enstage.wibmo.core.quartz.job;

import com.enstage.pc.common.PCInstance;
import com.enstage.pc.tm.KYCAutoUpgradeProcessor;
import com.wibmo.wallet.common.parameters.PCInstances;
import com.wibmo.wallet.common.db.ProgramConnectionPoolMapper;
import com.enstage.wibmo.core.quartz.annotations.On;
import com.enstage.wibmo.core.quartz.config.Job;
import java.util.Collection;
import java.util.Iterator;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.quartz.DisallowConcurrentExecution;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;

/**
 *
 * @author apeksha.ubhayakar
 */

//@On(value = "#{CRON_EXP_PROCESS_KYC_AUTO_UPGRADE_JOB}", jobName = "KYCAutoUpgradeQuartzJob")
@On(value = "${kYCAutoUpgradeQuartzJob}", jobName = "KYCAutoUpgradeQuartzJob")
@DisallowConcurrentExecution
public class KYCAutoUpgradeQuartzJob extends Job {

    private static final Logger logger = Logger.getLogger(KYCAutoUpgradeQuartzJob.class.getName());
    private static boolean running = false;
    
    public boolean isRunning() {
        return running;
    }

    @Override
    public void doJob(JobExecutionContext context) throws JobExecutionException {
        Collection<PCInstance> instanceList = PCInstances.getGeoInstanceList();
        if (instanceList != null && instanceList.isEmpty() == false) {
            Iterator<PCInstance> it = instanceList.iterator();
            PCInstances instance = null;

            logger.info("Starting KYCAutoUpgradeQuartzJob");

            Collection<ProgramConnectionPoolMapper> programListMapper;
            String programId;
            while (it.hasNext()) {
                instance = (PCInstances) it.next();
                programListMapper = ProgramConnectionPoolMapper.getInstanceList(instance);
                for (ProgramConnectionPoolMapper mapper : programListMapper) {
                    programId = mapper.getProgramId();
                    executeJob(instance, programId);
                }
            }
        }
    }

    public static void executeJob(PCInstance instance, String programId) {
        running = true;

        try {
            logger.log(Level.INFO, "KYCAutoUpgradeQuartzJob started for instance name: {0} and Program Id: {1}",
                    new Object[]{instance.getName(), programId});
            KYCAutoUpgradeProcessor.processAutoKycUpgradeForPCAccountByBatch(instance, programId);
            

        } catch (Exception e) {
            logger.log(Level.WARNING, "Error: " + e, e);
        } finally {
            running = false;
        }
        logger.log(Level.INFO, "KYCAutoUpgradeQuartzJob done for instance name: {0} and Program Id: {1}",
                new Object[]{instance.getName(), programId});
    }
    
    public static void startJob(){
        Collection<PCInstance> instanceList = PCInstances.getGeoInstanceList();
        if (instanceList != null && instanceList.isEmpty() == false) {
            Iterator<PCInstance> it = instanceList.iterator();
            PCInstances instance = null;

            logger.info("Starting KYCAutoUpgradeQuartzJob");

            Collection<ProgramConnectionPoolMapper> programListMapper;
            String programId;
            while (it.hasNext()) {
                instance = (PCInstances) it.next();
                programListMapper = ProgramConnectionPoolMapper.getInstanceList(instance);
                for (ProgramConnectionPoolMapper mapper : programListMapper) {
                    programId = mapper.getProgramId();
                    executeJob(instance, programId);
                }
            }
        }
    }

}


******************************************************
package com.enstage.pc.tm;

import com.enstage.pc.alert.AlertConstants;
import com.enstage.pc.alert.AlertHandler;
import com.enstage.pc.alert.AlertRequest;
import com.enstage.pc.am.AccountManagerInterface;
import com.enstage.pc.am.PCAccountMasterDAO;
import com.enstage.pc.am.PCLinkedCard;
import com.enstage.pc.am.UserPCAccountDAO;
import com.enstage.pc.am.impl.AccountManager;
import com.enstage.pc.am.impl.CMSConfig;
import com.enstage.pc.common.*;
import com.enstage.pc.common.ruleEngine.MasterRuleClient;
import com.enstage.pc.common.ruleEngine.ReasonForBlockResponse;
import com.enstage.pc.common.util.CommonUtil;
import com.enstage.pc.kyc.impl.KYCManager;
import com.enstage.pc.kyc.online.BankUserOnlineKYC;
import com.enstage.pc.tm.impl.SystemPushPullFundsManager;
import com.enstage.pc.um.impl.UserManager;
import com.enstage.pc.um.registration.UserProfileDAO;
import com.wibmo.wallet.common.exception.CryptoException;
import com.wibmo.wallet.common.parameters.PCParameters;
import com.wibmo.wallet.common.parameters.ProgramParameters;
import com.wibmo.wallet.common.pojo.PCAccountMaster;
import com.wibmo.wallet.common.pojo.UserPCAccount;
import com.wibmo.wallet.common.pojo.UserProfile;
import com.wibmo.wallet.common.util.CoreUtil;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Preeti
 */
public class KYCAutoUpgradeProcessor {

    private static final Logger logger = Logger.getLogger(KYCAutoUpgradeProcessor.class.getName());
    private static final String jobName = "KYC level upgrading job";

    public static void processAutoKycUpgradeForPCAccountByBatch(PCInstance instance, String programId){
        try {
            String jobStartTime = new Date() + "";
            int queueSize = 100;
            String queueSizeStr = PCParameters.getParameter(PCParamConstants.KYC_AUTO_UPGRADE_JOB_BLOCKING_QUEUE_SIZE_KEY);
            try {
                queueSize = Integer.parseInt(queueSizeStr);
            } catch (NumberFormatException e) {
                logger.log(Level.WARNING, "Invalid queue size configured: {0}" + e, queueSizeStr);
            }

            int limit = 500;
            String limitStr = PCParameters.getParameter(PCParamConstants.KYC_AUTO_UPGRADE_JOB_FETCH_LIMIT_KEY);
            try {
                limit = Integer.parseInt(limitStr);
            } catch (NumberFormatException e) {
                logger.log(Level.WARNING, "Invalid fetch limit configured: {0}" + e, queueSizeStr);
            }

            BlockingQueue blockingQueue = new ArrayBlockingQueue(queueSize);

            int threadCount = 10;
            String threadCountStr = PCParameters.getParameter(PCParamConstants.KYC_AUTO_UPGRADE_JOB_THREAD_COUNT_KEY);
            try {
                threadCount = Integer.parseInt(threadCountStr);
            } catch (NumberFormatException e) {
                logger.log(Level.WARNING, "Invalid thread count configured: {0}" + e, threadCountStr);
            }

            Consumer c[] = new Consumer[threadCount];
            Thread cThread[] = new Thread[threadCount];
            for(int i = 0; i < threadCount; i++) {
                c[i] = new Consumer(blockingQueue);
                cThread[i] = new Thread(c[i]);
                cThread[i].setName("KYCAutoUpgradeProcessor.Consumer["+programId+"]."+i);
                cThread[i].start();
            }


            DataForProcessAutoKycUpgrade dataForProcessAutoKycUpgrade;
            List<PCAccountMaster > pcamList;
            long processedCount;
            long erroredCount;

            while(true) {
                pcamList = getPCAccountMasterList(instance, programId, limit);
                if(pcamList == null || pcamList.isEmpty()) {
                    logger.log(Level.INFO, "No eligible records found...");
                    break;
                }

                for(PCAccountMaster pcAccountMaster : pcamList){
                    dataForProcessAutoKycUpgrade = new DataForProcessAutoKycUpgrade();
                    dataForProcessAutoKycUpgrade.instance = instance;
                    dataForProcessAutoKycUpgrade.pcAccountMaster = pcAccountMaster;
                    dataForProcessAutoKycUpgrade.programId = programId;
                    blockingQueue.put(dataForProcessAutoKycUpgrade);
                }

                while(blockingQueue.isEmpty() == false) {
                    logger.fine("waiting for pThread to finish.. (interim)");
                    Thread.currentThread().sleep(100);
                }

                processedCount = 0;
                erroredCount = 0;
                for(int i = 0; i < threadCount; i++) {
                    while(c[i].isProcessing) {
                        Thread.currentThread().sleep(100);
                    }
                    erroredCount = erroredCount + c[i].erroredCount;
                    processedCount = processedCount + c[i].processedCount;
                }

                if(erroredCount > (processedCount / 2)) { // To stop if 50 % of the records are not processed
                    logger.log(Level.WARNING, "Stop if 50 % of the records are not processed: {0};{1}", new Object[]{processedCount, erroredCount});
                    break;
                }

                if(limit > pcamList.size()) {
                    logger.log(Level.INFO, "Pcam list size less than fetch limit....ending job");
                    break;
                }
            }

            while(blockingQueue.isEmpty()==false) {
                logger.fine("waiting for pThread to finish.. (final)");
                Thread.currentThread().sleep(100);
            }

            erroredCount = 0;
            processedCount = 0;
            for(int i=0; i<threadCount; i++) {
                cThread[i].interrupt();
                erroredCount = erroredCount + c[i].erroredCount;
                processedCount = processedCount + c[i].processedCount;
            }
            String jobEndTime = new Date() + "";
            logger.log(Level.INFO, "processedCount: {0}", processedCount);
            logger.log(Level.INFO, "erroredCount: {0}", erroredCount);
            UserManager.notifySupportOnJobCompletion(instance, AlertConstants.ALERT_SUPPORT_ON_KYC_JOB_COMPLETION,
                    programId, jobName, processedCount, erroredCount, jobStartTime, jobEndTime);

        } catch (Exception e) {
            logger.log(Level.SEVERE, "Exception: "+e, e);
        }
    }

    static class DataForProcessAutoKycUpgrade {
        public PCInstance instance;
        public String programId;
        public PCAccountMaster pcAccountMaster;
    }

    public static boolean processKycUpgrade(DataForProcessAutoKycUpgrade dataForProcessAutoKycUpgrade) throws Exception {
        return processKycUpgrade(dataForProcessAutoKycUpgrade.instance, dataForProcessAutoKycUpgrade.pcAccountMaster,
                dataForProcessAutoKycUpgrade.programId);
    }

    static class Consumer implements Runnable {
        private static int instance = 0;
        private int instanceId;

        private BlockingQueue queue;
        long processedCount = 0;
        long erroredCount = 0;
        boolean isProcessing;

        Consumer(BlockingQueue q) {
            instanceId = ++instance;
            queue = q;
            logger.log(Level.FINEST, "Created..{0}", instanceId);
        }

        public void run() {
            logger.log(Level.FINEST, "Starting..{0}", instanceId);
            try {
                while (true) {
                    consume((DataForProcessAutoKycUpgrade) queue.take());
                }
            } catch (InterruptedException ex) {
                logger.log(Level.WARNING, "Error: " + ex, ex);
                Thread.currentThread().interrupt();
            } catch (Exception ex) {
                logger.log(Level.WARNING, "Error: " + ex, ex);
            }
            logger.log(Level.FINEST, "Done..{0}", instanceId);
        }

        void consume(DataForProcessAutoKycUpgrade dataForProcessAutoKycUpgrade) throws Exception {
            try {
                isProcessing = true;
                if(processKycUpgrade(dataForProcessAutoKycUpgrade)) {
                    processedCount++;
                } else {
                    erroredCount++;
                }
            } catch(Exception er) {
                logger.log(Level.WARNING, "Error! " + er, er);
                erroredCount++;
            } finally {
                isProcessing = false;
            }
        }
    }


    public static List<PCAccountMaster > getPCAccountMasterList(PCInstance instance, String programId, int limit){
        PreparedStatement pst = null;
        Connection conn = null;
        ResultSet rs = null;
        List<PCAccountMaster > pcamList =  new ArrayList<>();

        try {
            conn = instance.getGeoProgramDataConnection(programId);
            conn.setReadOnly(true);

            StringBuilder query = new StringBuilder();
            query.append("SELECT * FROM PC_AC_MASTER");
            query.append(" WHERE KYC_AUTO_UPGRADE = ? LIMIT ?");

            pst = conn.prepareStatement(query.toString());

            int i = 1;
            pst.setInt(i++, PCConstants.STATE_ACTIVE);
            pst.setInt(i++, limit);
            rs = pst.executeQuery();

            PCAccountMaster pcam = null;

            while (rs.next()) {
                try {
                    pcam = PCAccountMasterDAO.getFromRs(instance, rs);
                    pcamList.add(pcam);
                } catch (CryptoException e) {
                    logger.log(Level.WARNING, "Error while fetching pc account master :" + e, e);
                }
            }
        } catch (Exception e) {
            logger.log(Level.WARNING, "Error: " + e, e);
        } finally {
            CommonUtil.close(rs, pst, conn);
        }
        return pcamList;
    }
    
    public static boolean processKycUpgrade(PCInstance instance, PCAccountMaster pcam, String programId) throws Exception {
        AccountManagerInterface amInterface = AccountManager.getInstance(instance.getInstanceId(), programId);
        SystemPushPullFundsManager systemPushPullManager = new SystemPushPullFundsManager();
        boolean kycProcessed = false;
        boolean result = false;
        UserPCAccount userAccount = null;
        userAccount = UserPCAccountDAO.getByAcountNumber(instance, pcam.getPCAccountNumber(), programId);
        int oldPcKycLevel = pcam.getPcKycLevel();
        kycProcessed = systemPushPullManager.updateKycLevel(instance,
                instance, pcam, pcam.getPCAccountNumber(), pcam.getKycAutoUpgradeLevel(), userAccount.getUserId(),
                amInterface, programId);
        int kycUpgradeLevel = pcam.getKycAutoUpgradeLevel();
        logger.log(Level.INFO, "KYC upgrade for PCAccount: {0}, status: {1}", new Object[]{pcam.getPCAccountNumber(), kycProcessed});
        if (kycProcessed) {
            result = true;
            pcam.setEligibleForKycUpgrade(false);
            pcam.setKycAutoUpgradeLevel(0);
            boolean isUpdated = PCAccountMasterDAO.updateKycAutoUpgrade(instance, programId,pcam);
            if (isUpdated) {
            	logger.log(Level.INFO, "2. Before checking inactivity or temporary block, Reason code: {0}, WalletStatus: {1}", new Object[] {pcam.getReasonCode(), pcam.getWalletStatus()});
            	
                String isInactivityTempUnblockCheckEnabled = ProgramParameters.getParameter(instance, programId, ProgramParamConstants.INACTIVITY_TEMP_UNBLOCK_CHECK_ENABLED);
                if ("true".equalsIgnoreCase(isInactivityTempUnblockCheckEnabled) == false || !((PCAccountMaster.REASON_CODE_INACTIVITY.equals(pcam.getReasonCode())
                        || PCAccountMaster.REASON_CODE_TEMPORARY_BLOCKED.equals(pcam.getReasonCode())
                        && (PCAccountMaster.WALLET_ACTIVE != pcam.getWalletStatus() || PCAccountMaster.WALLET_ACTIVE != pcam.getCashBackWalletStatus())))) {
                    logger.info("Going through master rule");
                    try {
                        if(null != pcam.getBankAccount()) {
                            CMSConfig cmsConfig = KYCManager.getCmsConfig(instance, programId);
                            ReasonForBlockResponse blockResponse = MasterRuleClient.getNextApplicableWalletStatus(instance,
                                    programId, pcam, pcam.getWalletStatus(), pcam.getReasonCode(),PCLinkedCard.REGULAR_WALLET_TYPE);
                            int blockWalletStatus = (blockResponse != null ? Integer.parseInt(blockResponse.getBlockStatusCode()) : 0);

                            if (blockResponse != null && PCAccountMaster.WALLET_ACTIVE != pcam.getWalletStatus()
                                    && PCAccountMaster.WALLET_ACTIVE != blockWalletStatus && blockWalletStatus != pcam.getWalletStatus()) {
                                KYCManager.processWalletStatus(instance, programId, cmsConfig, pcam,
                                        pcam.getReasonCode(), PCAccountMasterDAO.getPrepaidWalletStatusMap("" + PCAccountMaster.WALLET_ACTIVE),
                                        PCAccountMaster.WALLET_ACTIVE, false, 0, PCLinkedCard.REGULAR_WALLET_TYPE);
                            }
                            if (blockResponse != null && pcam.getWalletStatus() != blockWalletStatus) {
                                KYCManager.processWalletStatus(instance, programId, cmsConfig, pcam,
                                        //blockResponse.getBlockReasonCode() != null ? blockResponse.getBlockReasonCode() : pcam.getReasonCode(),
                                        blockResponse.getBlockReasonCode(),
                                        PCAccountMasterDAO.getPrepaidWalletStatusMap(blockResponse.getBlockStatusCode()), blockWalletStatus,
                                        blockWalletStatus != PCAccountMaster.WALLET_ACTIVE, UserManager.getEventIdForWalletStatus(blockWalletStatus)
                                        ,PCLinkedCard.REGULAR_WALLET_TYPE);
                            }
                        }
                        // CB
                        String isCashbackWalletEnabledStr = ProgramParameters.getParameter(instance, programId, ProgramParamConstants.CASHBACK_WALLET_ENABLED);
                        if(Boolean.parseBoolean(isCashbackWalletEnabledStr) && null != pcam.getCashbackBankAccount()) {
                            CMSConfig cbcmsConfig = KYCManager.getCBCmsConfig(instance, programId);
                            ReasonForBlockResponse blockResponse = MasterRuleClient.getNextApplicableWalletStatus(instance,
                                    programId, pcam, pcam.getCashBackWalletStatus(), pcam.getReasonCode(),PCLinkedCard.CASHBACK_WALLET_TYPE);
                            int blockWalletStatus = (blockResponse != null ? Integer.parseInt(blockResponse.getBlockStatusCode()) : 0);
                            if (blockResponse != null && PCAccountMaster.WALLET_ACTIVE != pcam.getCashBackWalletStatus()
                                    && PCAccountMaster.WALLET_ACTIVE != blockWalletStatus && blockWalletStatus != pcam.getCashBackWalletStatus()) {
                                KYCManager.processWalletStatus(instance, programId, cbcmsConfig, pcam,
                                        pcam.getCashBackReasonCode(), PCAccountMasterDAO.getPrepaidWalletStatusMap("" + PCAccountMaster.WALLET_ACTIVE),
                                        PCAccountMaster.WALLET_ACTIVE, false, 0,PCLinkedCard.CASHBACK_WALLET_TYPE);
                            }
                            if (blockResponse != null && pcam.getCashBackWalletStatus() != blockWalletStatus) {
                                KYCManager.processWalletStatus(instance, programId, cbcmsConfig, pcam,
                                        //blockResponse.getBlockReasonCode() != null ? blockResponse.getBlockReasonCode() : pcam.getReasonCode(),
                                        blockResponse.getBlockReasonCode(),
                                        PCAccountMasterDAO.getPrepaidWalletStatusMap(blockResponse.getBlockStatusCode()), blockWalletStatus,
                                        blockWalletStatus != PCAccountMaster.WALLET_ACTIVE, UserManager.getEventIdForWalletStatus(blockWalletStatus)
                                         , PCLinkedCard.CASHBACK_WALLET_TYPE);
                            }
                        }
                    } catch (Exception e) {
                        logger.log(Level.WARNING, "Error: " + e, e);
                    }
                } else {
                    logger.log(Level.INFO, "Skipping master rule as the wallet is blocked due to inactivity or temporary block, reason code : {0}", pcam.getReasonCode());
                }
            }
            //Adding the logic for updating AuthStatus against CustID - DOWNGRADED_BY_JOB
            try {
                if(oldPcKycLevel == PCKYCLevels.I_KYC) {
                    List<BankUserOnlineKYC> bankList = null;
                    bankList = new BankUserOnlineKYC().getSuccessCustIdList(instance, programId, pcam.getPCAccountNumber());
                    if(bankList.size() > 0) {
                        boolean isDowngraded = new BankUserOnlineKYC().updateDowngradedStatus(instance, programId, pcam.getPCAccountNumber());
                        if(isDowngraded)
                            logger.log(Level.INFO, "BankUserOnlineKycData is updated with Downgraded flag for account: {0}", pcam.getPCAccountNumber());
                        else
                            logger.log(Level.INFO, "BankUserOnlineKycData Failed to update with Downgraded flag for account: {0}", pcam.getPCAccountNumber());
                    } else {
                        logger.log(Level.INFO, "BankUserOnlineKycData Auth-Success entry not found for account: {0}", pcam.getPCAccountNumber());
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, "Error in Updating/Downgrading the iKYC Customer : " + e, e);
            }
            // END - Downgrade iKYC TABLE update
            int eventId = 0;
            logger.log(Level.INFO, "KycAutoUpgradeLevel() : {0}", kycUpgradeLevel);
            switch (kycUpgradeLevel) {
                case PCKYCLevels.E_KYC:
                    eventId = AlertConstants.ALERT_EKYC_UPGRADE;
                    break;
                case PCKYCLevels.I_KYC:
                    eventId = AlertConstants.ALERT_IKYC_UPGRADE;
                    break;
                default:
                    //eventId = AlertConstants.ALERT_KYC_UPGRADE;
                    break;
            }
            notifyUserForKYCUpgrade(instance, userAccount.getUserId(), pcam.getProgramId(), eventId);
        }
        try {
            if( pcam.getPcKycLevel() == PCKYCLevels.I_KYC) {
                if (!lockUserProfileForIKYCUser(instance, programId, pcam.getPCAccountNumber())){
                    logger.log(Level.WARNING, "Unable to lock user profile for account: {0}", pcam.getPCAccountNumber());
                } else {
                    logger.log(Level.FINE, "locked user profile for account: {0}", pcam.getPCAccountNumber());
                }
            }
        } catch (Exception e) {
            logger.log(Level.WARNING, "Error: " + e, e);
        }
        return result;
    }
    
    private static boolean lockUserProfileForIKYCUser (PCInstance instance, String programId,
                                                                  String pcAccNumber){
        UserPCAccount paAcc = UserPCAccountDAO.getByAcountNumber(instance, pcAccNumber, programId);
        if (null == paAcc){
            logger.log(Level.WARNING, "Unable to get UserPCAccount for account {0}", pcAccNumber);
            return false;
        } else {
            try {
                return UserManager.lockUserProfile(instance, paAcc.getUserId(), programId, true);
            } catch (Exception e) {
                logger.log(Level.WARNING, "Exception occured during lock profile for account: {0}", pcAccNumber);
                return false;
            }
        }
    }
    
    private static boolean notifyUserForKYCUpgrade(PCInstance instance, String userId, String programId, int eventId) {
        boolean isAlertSent = false;
        try {

            AlertRequest alert = new AlertRequest();
            alert.setInstance(instance);
            alert.setEventId(eventId);
            alert.setProgramId(programId);

            UserProfile senderProfile = UserProfileDAO.getUserProfileWithPrimaryAccessDataByUserId(instance,
                    userId, programId);
            if (senderProfile == null) {
                logger.log(Level.WARNING, "Sender Profile was null: ", userId);
                return false;
            }
            alert.setRecipientEmail(senderProfile.getEmail());
            StringBuilder recipientName = CoreUtil.trimBigName(30, senderProfile.getFirstName(), senderProfile.getLastName());
            alert.setRecipientName(recipientName.toString());
            alert.setRecipientMobile(senderProfile.getMobile());
            ProgramMaster programMaster = ProgramMaster.getProgramMaster(programId);
            alert.setProgramName(programMaster.getProgramName());
            alert.setSupportEmail(ProgramParameters.getParameter(
                    instance, programMaster.getProgramId(), ProgramParamConstants.SUPPORT_EMAIL_KEY));
            alert.setSupportMobile(ProgramParameters.getParameter(
                    instance, programMaster.getProgramId(), ProgramParamConstants.SUPPORT_MOBILE_NO_KEY));
            alert.setUrlDomain(ProgramParameters.getParameter(
                    instance, programMaster.getProgramId(), ProgramParamConstants.URL_DOMAIN));

            isAlertSent = AlertHandler.notifyUserUsingRestService(alert);

        } catch (Exception e) {
            logger.log(Level.WARNING, "Error: " + e, e);
        }
        return isAlertSent;
    }
}


***********************************************************
